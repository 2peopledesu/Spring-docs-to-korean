---
title: Operators and Casting
date: 2025-03-07
weight: 3
---

# 3장: Java의 연산자 이해하기

2장에서 우리는 변수가 단순히 이름이 붙은 메모리 위치이며 값을 포함하고 있다는 것을 배웠습니다. 이러한 값은 다양하며, Java는 이에 따라 8개의 기본 데이터 타입을 제공합니다. 이러한 기본 타입은 정수(바이트, 문자, 쇼트, 인트, 롱), 소수(플로트, 더블), 그리고 리터럴 true와 false(부울)를 포함합니다.

변수를 선언하는 방법도 배웠습니다. Java는 강타입 언어이므로, 변수를 선언할 때마다 데이터 타입을 지정해야 합니다. 이 점에서 기본 데이터 타입은 매우 유용합니다.

이제 변수를 선언하는 방법을 알았으니, 이를 활용하여 흥미로운 작업을 해보겠습니다. 이 장이 끝날 때쯤이면 Java의 다양한 연산자를 사용하여 변수를 결합할 수 있게 될 것입니다. 또한 Java 캐스팅에 대해서도 이해하게 될 것입니다. 캐스팅이란 무엇인지, 언제, 왜 발생하는지에 대해서도 다룰 것입니다.

이 장에서는 다음과 같은 주요 주제를 다룰 것입니다:
- Java의 연산자가 어떻게 협력하는지 배우기
- Java의 연산자 이해하기
- Java 캐스팅 설명하기

## 기술 요구 사항

이 장의 코드는 GitHub에서 확인할 수 있습니다: [GitHub 링크](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3).

## Java의 연산자가 협력하는 방법 배우기

Java는 우리가 작업할 수 있는 수많은 연산자를 제공합니다. 정의하자면, 표현식 `3 + 4`에서 `+`는 연산자이고, `3`과 `4`는 피연산자입니다. `+`는 두 개의 피연산자를 가지므로 이진 연산자로 알려져 있습니다.

연산자 자체를 논의하기 전에, Java 연산자와 관련된 두 가지 중요한 기능인 우선 순위와 결합성에 대해 먼저 논의해야 합니다.

### 우선 순위

우선 순위는 피연산자가 연산자와 어떻게 그룹화되는지를 지정합니다. 이는 복잡한 표현식에서 공유 피연산자가 있을 때 중요해집니다. 다음 코드 조각을 살펴보겠습니다:

```java
int a = 2 + 3 * 4;
System.out.println(a);
```

위 코드에서 `3`은 `2`와 `4` 모두에 공유됩니다. 따라서 질문이 생깁니다. `3`을 `2`와 그룹화하여 `(2 + 3) * 4`로 계산할 것인가, 아니면 `3`을 `4`와 그룹화하여 `2 + (3 * 4)`로 계산할 것인가? 여기서 우선 순위가 적용됩니다. `*`는 `+`보다 우선 순위가 높기 때문에 `3`은 `4`와 그룹화되어 표현식은 `2 + (3 * 4)`로 평가됩니다. 평가 순서는 여전히 왼쪽에서 오른쪽으로 진행되며, 단지 `3`이 `2`가 아닌 `4`와 그룹화된 것입니다.

### 표현식의 괄호

괄호는 기본 연산자 우선 순위를 변경할 수 있습니다. 기본 우선 순위에서 `*`가 `+`보다 높은 경우, `2 + 3 * 4`는 `14`입니다. 이는 `2 + (3 * 4)`와 동일합니다.

그러나 `(2 + 3) * 4`는 `20`입니다. 이 경우 괄호가 `3`을 `2`와 그룹화하였기 때문에 표현식은 `5 * 4 = 20`으로 평가됩니다.

이제 같은 우선 순위의 연산자가 포함된 표현식을 평가할 때는 어떻게 될까요? 이 경우 결합성이 적용됩니다.

### 결합성

표현식에 동일한 우선 순위의 두 개의 연산자가 있을 때, 연산자 결합성은 연산자와 피연산자의 그룹화를 결정합니다. 예를 들어, 다음 코드 조각에서는 두 개의 나눗셈이 포함된 간단한 표현식을 평가하고 있습니다:

```java
int x = 72 / 6 / 3;
```

나눗셈은 왼쪽에서 오른쪽으로 결합되므로 `6`은 `72`와 그룹화되고 `3`과는 그룹화되지 않습니다. 따라서 표현식은 `(72 / 6) / 3`과 동일하며, 이는 `12 / 3 = 4`로 평가됩니다. 괄호를 사용하여 기본 결합성 순서를 변경할 수도 있습니다. 예를 들어:

```java
int x = 72 / (6 / 3);
```

이 경우 `6`은 이제 `3`과 그룹화되어 표현식은 `72 / 2 = 36`으로 평가됩니다.

우선 순위 표에서 할당 연산자 `=`가 가장 낮은 위치에 있다는 점도 흥미롭습니다. 이는 할당의 오른쪽에 있는 표현식이 무엇이든 간에 할당이 항상 마지막에 수행된다는 것을 의미합니다. 이는 논리적입니다. 또한 대부분의 연산자는 왼쪽에서 오른쪽으로 결합되지만, 할당은 오른쪽에서 왼쪽으로 결합됩니다. 다음 코드 조각에서 이를 보여줍니다:

```java
boolean b1 = false;
boolean b2;
boolean b3;
b3 = b2 = b1;
System.out.println(b1);
System.out.println(b2);
System.out.println(b3);
```

위 코드 조각은 `false`를 세 번 출력합니다. 중요한 줄은 `b3 = b2 = b1;`입니다. 할당이 오른쪽에서 왼쪽으로 결합되므로, `b1`의 값인 `false`가 `b2`에 할당되고, 그 다음 `b2`의 값인 `false`가 `b3`에 할당됩니다.

이제 이러한 속성을 이해했으니, 연산자 자체를 살펴보겠습니다.

## Java의 연산자 이해하기

연산자는 다음과 같은 카테고리로 그룹화할 수 있습니다:
- 단항 연산자 (Unary operators)
- 산술 연산자 (Arithmetic operators)
- 관계 연산자 (Relational operators)
- 논리 연산자 (Logical operators)
- 삼항 연산자 (Ternary operator)
- 복합 할당 연산자 (Compound assignment operators)

이제 각 카테고리에 대해 차례로 논의하겠습니다.

### 단항 연산자

단항 연산자는 피연산자가 하나만 있는 연산자입니다. 이들을 살펴보겠습니다.

#### 접두사 및 접미사 단항 연산자

`++`와 `--`는 각각 1씩 증가 및 감소시키는 연산자를 나타냅니다. 연산자가 변수 앞에 나타나면 접두사(prefix)라고 하고, 변수 뒤에 나타나면 접미사(postfix)라고 합니다. 예를 들어, `++x`는 접두사 증가이고, `y--`는 접미사 감소입니다.

`++` 또는 `--`가 변수 앞이나 뒤에 나타나는지에 따라 전체 표현식에 영향을 미칠 수 있습니다. 

다음은 예시 코드입니다:

```java
int x = 3; // x를 3으로 초기화
x++; // x를 1 증가시켜 4로 만듭니다.
System.out.println(x); // x의 현재 값은 4입니다.

System.out.println(x++); // 현재 x의 값(4)을 출력한 후 x를 1 증가시킵니다.
System.out.println(x); // x의 현재 값은 5입니다.

int y = 4; // y를 4로 초기화
y--; // y를 1 감소시켜 3으로 만듭니다.
System.out.println(y); // y의 현재 값은 3입니다.

System.out.println(--y); // y를 1 감소시킨 후 현재 값(2)을 출력합니다.
System.out.println(y); // y의 현재 값은 2입니다.
```

위 코드에서:
- 라인 25에서 `x`는 3으로 초기화됩니다.
- 라인 26에서 `x`는 1 증가하여 4가 됩니다.
- 라인 27에서 `x`의 값이 출력되어 4가 표시됩니다.
- 라인 28에서 `System.out.println(x++)`는 현재 `x`의 값(4)을 출력한 후 `x`를 1 증가시킵니다. 따라서 출력은 4이고, 이후 `x`는 5가 됩니다.
- 라인 29에서 `x`의 값이 5임을 보여줍니다.
- 라인 31에서 `y`는 4로 초기화됩니다.
- 라인 32에서 `y`는 1 감소하여 3이 됩니다.
- 라인 33에서 `y`의 값이 출력되어 3이 표시됩니다.
- 라인 34에서 `System.out.println(--y)`는 `y`를 1 감소시킨 후 현재 값(2)을 출력합니다. 따라서 출력은 2입니다.
- 마지막으로, 라인 35에서 `y`의 현재 값이 2임을 보여줍니다.

#### 단항 더하기/빼기 연산자

이제 접두사 및 접미사 연산자에 대해 논의했으므로, 다른 단항 연산자에 대해 살펴보겠습니다. 다음은 예시 코드입니다:

```java
int x = +6; // 단항 더하기 연산자 사용
int y = -x; // 단항 빼기 연산자 사용
```

위 코드에서:
- 라인 37은 단항 더하기 기호 `+`를 사용하여 `x`를 6으로 초기화합니다. 여기서 `+`는 기본값으로, 부호가 없는 숫자는 양수로 간주됩니다.
- 라인 38은 단항 빼기 기호 `-`를 사용하여 `y`를 `x`의 음수로 초기화합니다.
- 라인 39와 40은 각각 `x`와 `y`의 값이 6과 -6임을 보여줍니다.

---
코드 사진은 올리지 않겠습니다. 깃헙에 가서 확인해주세요.
---

## 캐스트 연산자

3.2에서 라인 42는 캐스트 연산자를 사용합니다. 캐스팅에 대해서는 이 장에서 더 자세히 논의할 것입니다. 현재로서는 `3.45`가 더블 리터럴(8바이트)이며, 이는 `int` 변수 `z`에 저장할 수 없다는 점을 이해해야 합니다. `int` 변수는 4바이트 크기이기 때문입니다. 컴파일러는 이를 감지하고 오류를 발생시킵니다. 이 오류를 해결하기 위해 캐스트를 사용할 수 있으며, 이는 `(cast type)` 형태를 가집니다. 이 캐스트는 컴파일러 오류를 무시할 수 있게 해줍니다. 이 경우, `3.45`를 `int` 변수로 캐스팅하므로 소수점 이하가 손실됩니다. 따라서 `z`에 `3`이 저장됩니다.

### 논리 NOT 연산자

3.2에서 라인 45에서는 불리언 `b`를 선언하고 `true`로 초기화합니다. 라인 46에서는 논리 NOT 연산자를 사용하여 `b`의 반전된 값을 출력합니다. 여기서 `b`의 값은 변경되지 않으며, 여전히 `true`입니다. 이는 라인 47의 출력에서 확인할 수 있습니다.

이제 산술 연산자를 살펴보겠습니다.

### 산술 연산자

산술 연산자는 총 5개가 있으며, 지금부터 각각을 살펴보겠습니다.

#### 덧셈/뺄셈 연산자

수학과 마찬가지로, `+` 연산자는 덧셈을 나타내고, `-` 연산자는 뺄셈을 나타냅니다. 두 연산자는 모두 이진 연산자이며, 즉 두 개의 피연산자가 있습니다. 다음 코드 예제를 통해 이를 보여줍니다:

```java
int res = 6 + 4 - 2;
System.out.println(res); // 8
```

위 코드 조각에서 `res`는 `6 + 4 - 2`의 값인 `8`로 할당됩니다.

#### 곱셈/나눗셈 연산자

`*` 연산자는 곱셈을 나타내고, `/` 연산자는 나눗셈을 나타냅니다. 두 연산자 모두 이진 연산자입니다. 정수 나눗셈은 소수점을 버린다는 점에 유의해야 합니다. 다음 코드 조각이 이를 보여줍니다:

```java
System.out.println(10 / 3); // 3
```

이 코드 조각은 `3`을 출력합니다. 이는 정수 나눗셈이 소수점을 버리기 때문입니다. `10`을 `3`으로 나누면 나머지는 단순히 버려집니다.

#### 나머지 연산자

`%` 연산자는 나머지(모듈러스)를 계산하는 데 사용됩니다. 다음 코드 예제가 나머지 연산자의 작동을 보여줍니다:

```java
int mod1 = 10 % 3;
System.out.println(mod1); // 1
int mod2 = 0 % 3;
System.out.println(mod2); // 0
```

첫 번째 줄은 `10`을 `3`으로 나눈 나머지인 `1`로 `mod1`을 초기화합니다. 즉, `3`은 `10`에 세 번 들어가고 `1`이 남습니다. 따라서 `1`이 `mod1`에 할당됩니다.

`mod2`의 초기화는 흥미롭습니다: `3`은 `0`에 들어갈 수 없으므로 남는 것은 `0`입니다. 따라서 `0`이 `mod2`에 할당됩니다.

#### 산술 연산자의 우선 순위

표 3.1에 따르면, `*`, `/`, `%`는 `+`와 `-` 연산자보다 높은 우선 순위를 가지며, 할당은 가장 낮은 우선 순위를 가집니다. 그림 3.3은 코드에서 표현식의 평가에 어떻게 영향을 미치는지를 보여줍니다:

라인 61은 `*`가 `+`보다 높은 우선 순위를 가지므로 표현식이 `3 + (2 * 4)`로 평가되어 `3 + 8 = 11`이 됩니다.

라인 63은 괄호가 그룹화를 변경하는 것을 보여줍니다. 이제 공유 값인 `2`가 `3`과 그룹화되어(라인 61의 경우 `4`와는 다르게) 표현식이 `5 * 4 = 20`으로 평가됩니다.

라인 65는 `+`와 `-`가 왼쪽에서 오른쪽으로 결합됨을 보여줍니다. 표현식은 `10 - 2 = 8`로 평가됩니다.

라인 67은 `*`, `/`, `%`도 왼쪽에서 오른쪽으로 결합됨을 보여줍니다. 표현식은 `2 * 6 % 10`으로 평가되며, 이는 다시 `12 % 10`으로 평가되어 `2`가 됩니다.

### int 변수 또는 더 작은 타입을 포함하는 수학 연산은 int로 결과가 나옵니다

int 타입 또는 더 작은 타입을 포함하는 모든 수학 연산의 결과가 int라는 점은 흥미롭습니다. 다음 코드 조각이 이를 보여줍니다:

```java
byte b1 = 2, b2 = 3;
byte b3 = b1 + b2; // 컴파일러 오류
byte b4 = (byte)(b1 + b2); // 정상 동작
```

첫 번째 줄은 `b1`과 `b2`라는 두 개의 바이트를 선언합니다. 2와 3이 정수 리터럴이지만, 컴파일러는 이 값들이 바이트 범위(-128에서 +127) 내에 있다는 것을 인식하므로 선언을 허용합니다.

그러나 다음 줄은 문제가 됩니다. 컴파일러는 int 타입 또는 더 작은 타입을 포함하는 모든 수학 연산의 결과가 int라는 규칙을 가지고 있습니다. 따라서 두 바이트의 합인 5가 바이트 범위 내에 충분히 있음에도 불구하고, 컴파일러는 "int에서 byte로 변환 시 데이터 손실 가능성"이라는 오류를 발생시킵니다.

마지막 줄은 할당 전에 덧셈 결과(int 타입)를 바이트로 캐스팅하여 이 문제를 해결합니다. 이는 int에서 바이트에 맞지 않는 추가 3바이트가 단순히 버려진다는 것을 의미합니다. 따라서 `b1 + b2`의 합은 int에서 바이트로 캐스팅되고, 결과 바이트가 `b4`에 할당됩니다. 캐스팅에 대해서는 이 장의 뒷부분에서 더 자세히 논의됩니다.

다른 문맥에서 `+`를 검토하면서 산술 연산자에 대한 논의를 마무리하겠습니다.

### 문자열 추가(String append)

우리가 보았듯이, Java는 수학적 덧셈에 `+`를 사용합니다. 그러나 이는 두 피연산자가 모두 숫자인 경우에만 발생합니다. 예를 들어, `3 + 4`는 두 피연산자인 3과 4가 모두 숫자이므로 7이 됩니다.

그러나 피연산자 중 하나(또는 둘 다)가 문자열인 경우, Java는 문자열 추가(String append)를 수행합니다. 문자열 리터럴은 이중 따옴표로 묶여 있습니다. 예를 들어, "abc", "123", "Sean", "Maaike"는 모두 문자열 리터럴입니다. 어떤 연산이 언제 수행되는지 명확히 하기 위해 몇 가지 예를 살펴보겠습니다:

- `3 + 4`는 수학적 덧셈입니다. 따라서 결과는 7입니다.
- `"3" + 4`는 `+`의 왼쪽에 문자열이 있으므로 문자열 추가입니다. 결과는 문자열 "34"입니다.
- `3 + "4"`는 `+`의 오른쪽에 문자열이 있으므로 문자열 추가입니다. 결과는 문자열 "34"입니다.
- `"3" + "4"`는 `+`의 양쪽에 문자열이 있으므로 문자열 추가입니다. 결과는 문자열 "34"입니다.

그렇다면 문자열 추가 중에 정확히 무슨 일이 발생할까요? Java는 피연산자의 타입이 다른 경우 수학적 연산을 수행할 수 없습니다. 예시 코드를 통해 이를 살펴보겠습니다:

```java
String s = "3" + 4;
System.out.println(s); // "34"
```

첫 번째로 주목할 점은, 첫 번째 코드 라인이 컴파일되는 것은 `"3" + 4`가 문자열 리터럴을 결과로 내기 때문입니다. Java가 `+`의 왼쪽/오른쪽/양쪽에 문자열을 발견하면 문자열 연결(추가)을 수행합니다. 기본적으로 `+`는 왼쪽에서 오른쪽으로 결합되므로, Java는 `+`의 오른쪽에 있는 문자열을 `+`의 왼쪽에 있는 문자열의 끝에 추가(더함)합니다.

이 예에서, Java는 문자열 리터럴 `"3"`과 `+` 연산자를 보고 문자열 추가를 수행해야 한다고 인식합니다. 이를 위해 메모리에 4의 문자열 버전을 생성합니다. 즉, `"4"`입니다. 정수 4 리터럴은 변경되지 않습니다. 따라서 내부적으로 새 변수가 생성됩니다. 이는 문자열 변수이며, `"4"`가 그 값입니다. 표현식은 이제 `"3" + "4"`입니다. `+`의 양쪽에 있는 두 피연산자가 이제 동일한 타입(둘 다 문자열)이므로, Java는 추가를 수행할 수 있습니다. 새 문자열은 `"3" + "4"`의 결과인 `"34"`입니다. 이것이 `s`에 할당되는 값입니다. 두 번째 줄은 `s`의 값으로 `"34"`를 출력하여 이를 보여줍니다.

그림 3.4에서는 더 실질적인 예시가 제시됩니다:

라인 79에서는 두 피연산자 `a`와 `b`가 모두 정수이므로, Java는 `res`를 3과 2의 합인 5로 초기화합니다.

라인 82는 다음과 같이 평가됩니다: `3 + "abc" = "3" + "abc" = "3abc"`. 즉, Java는 `+`의 오른쪽에 `"abc"`가 있어 문자열 추가를 해야 한다는 것을 인식합니다. 따라서 메모리 어딘가에 `a` 값의 문자열 버전이 생성됩니다. 다시 말해, `"3"`이라는 값을 가진 변수가 생성됩니다. `a`는 여전히 3이라는 값을 가진 int 타입이라는 점에 유의하세요. 이제 두 피연산자가 동일한 타입(문자열)이므로 Java는 처리를 계속할 수 있습니다: `"3" + "abc"`는 `"3abc"`가 됩니다.

라인 83은 문자열이 `+`의 어느 쪽에 있는지는 중요하지 않다는 것을 보여줍니다. 또한 문자열이 문자열 리터럴인지 문자열 변수인지도 중요하지 않습니다. 라인 83의 표현식은 다음과 같이 평가됩니다: `"abc" + 3 = "abc" + "3" = "abc3"`. 이것이 `s2`가 초기화되는 값입니다. 라인 84는 `s1`과 `s2`의 값을 사이에 공백을 두고 출력합니다. `System.out.println`은 문자열을 예상한다는 점에 유의하세요. 라인 84에서 출력되는 문자열은 다음과 같이 구성됩니다: `"3abc" + " " = "3abc " + "abc3" = "3abc abc3"`.

라인 86과 87은 특별히 언급할 필요가 있습니다. 라인 86의 문제는 출력 문자열이 다음과 같이 구성된다는 것입니다: `"Output is " + 3 = "Output is " + "3" = "Output is 3" + 2 = "Output is 3" + "2" = "Output is 32"`. 이는 우리가 원하는 결과가 아닙니다.

라인 87은 괄호를 사용하여 `a + b`가 그룹화되도록 함으로써 이를 해결합니다. 따라서 문자열은 다음과 같이 구성됩니다: `"Output is " + 5 = "Output is " + "5" = "Output is 5"`.

이로써 산술 연산자에 대한 설명을 마치겠습니다. 이제 관계 연산자를 살펴보겠습니다.

# 관계 연산자와 논리 연산자

## 관계 연산자

Java는 모두 불리언 값 `true` 또는 `false`를 결과로 내는 6개의 관계 연산자를 제공합니다:

- `==`: 동등 연산자
- `!=`: 같지 않음 연산자 
- `>`: 크다 연산자
- `>=`: 크거나 같다 연산자
- `<`: 작다 연산자
- `<=`: 작거나 같다 연산자

```java
int x = 3, y = 4;
System.out.println(x == y); // false
System.out.println(x != y); // true
System.out.println(x > y);  // false
System.out.println(x >= y); // false
System.out.println(x < y);  // true
System.out.println(x <= y); // true
```

위 코드에서 `x`와 `y`가 같지 않으므로 `x == y`는 `false`를 출력합니다. 반대로 `x != y`는 `true`입니다. `x`가 `y`보다 작으므로 `x > y`와 `x >= y`는 `false`이고, `x < y`와 `x <= y`는 `true`입니다.

관계 연산자와 그 불리언 반환 값은 특히 4장에서 배울 조건문에서 매우 유용하게 사용됩니다.

### 묵시적 타입 변환(Implicit promotion)

Java의 연산자는 피연산자가 정확히 동일한 타입일 필요는 없지만, 호환 가능해야 합니다. 다음 코드를 살펴보세요:

```java
System.out.println(3 + 4.0); // 7.0
System.out.println(4 == 4.0); // true
```

첫 번째 줄은 정수 `3`과 실수 `4.0`을 더하려고 합니다. Java는 타입이 같지 않다는 것을 인식하지만, 우리에게 알리지 않고 안전한 해결책을 찾습니다. 이때 묵시적 타입 변환이 발생합니다. `int`는 4바이트의 저장 공간을 필요로 하는 반면, `double`은 8바이트를 필요로 합니다. 내부적으로 Java는 임시 `double` 변수를 선언하고 정수 `3`을 실수 `3.0`으로 변환하여 이 임시 위치에 저장합니다. 이제 Java는 `3.0`과 `4.0`을 더할 수 있으며(둘 다 `double`이므로), 결과는 `7.0`입니다.

두 번째 줄은 정수 `4`와 실수 `4.0`을 비교합니다. 동일한 과정이 발생합니다. Java는 묵시적으로 `4`를 `4.0`으로 변환하고(새 임시 위치에) `4.0`과 `4.0`을 비교합니다. 이는 `true`를 출력합니다.

## 논리 연산자

논리 연산자는 하위 표현식을 결합하여 복잡한 불리언 표현식을 구성할 수 있게 합니다. 주요 논리 연산자는 다음과 같습니다:

- `&&`: 논리 AND
- `||`: 논리 OR
- `&`: 비트 AND
- `|`: 비트 OR
- `^`: 비트 배타적 OR(XOR)

### 논리 AND(`&&`)

논리 AND는 전체 표현식이 참이 되기 위해서는 두 불리언 피연산자가 모두 참이어야 함을 나타냅니다. 진리표로 표현하자면:

| P | Q | P && Q |
|---|---|-------|
| T | T | T     |
| T | F | F     |
| F | T | F     |
| F | F | F     |

이 연산자는 단락 평가(short-circuit) 연산자로 알려져 있습니다. 예를 들어, `P && Q` 표현식에서 `P`가 `false`로 평가되면, `&&`는 전체 표현식이 어쨌든 `false`로 평가되므로 표현식 `Q`를 평가하지 않습니다. 이는 `F && F`가 거짓이고 `F && T`도 거짓이기 때문입니다. 실제로 Java는 `&&` 표현식의 왼쪽에 있는 표현식 `P`가 거짓이면 전체 표현식은 반드시 거짓이라는 것을 알고 있습니다. 따라서 오른쪽에 있는 `Q` 표현식을 평가할 필요가 없으므로 단락 평가가 발생합니다.

```java
boolean b1 = false, b2 = true;
boolean res = b1 && (b2 = false); // F && (평가되지 않음)
System.out.println(b1 + " " + b2 + " " + res); // false true false
```

위 코드에서 첫 번째 줄은 두 불리언 변수 `b1`과 `b2`를 각각 `false`와 `true`로 초기화합니다. 두 번째 줄이 중요합니다. `b2=false` 하위 표현식 주위에 괄호가 필요합니다(그렇지 않으면 구문 오류가 발생). `b1`에 `false`를 대입하면 표현식은 `F && (b2=false)`로 평가됩니다. 평가 순서가 왼쪽에서 오른쪽이므로, 표현식에 무엇이 남아 있든 전체 표현식이 참이 될 방법이 없기 때문에 `&&`는 단락 평가됩니다. 이는 `(b2=false)` 하위 표현식이 실행되지 않음을 의미합니다.

마지막 줄은 변수의 값을 출력합니다. `b1`, `b2`, `res`에 대한 출력은 각각 `false`, `true`, `false`입니다. 중요한 점은 `b2`가 `true`라는 것으로, 이는 `&&`가 단락 평가되었음을 보여줍니다.

> **참고**: 단락 평가는 코드의 효율성을 높이는 데 도움이 되지만, 때로는 의도하지 않은 결과를 초래할 수 있습니다. 특히 두 번째 피연산자에 부수 효과(side effect)가 있는 경우 주의해야 합니다.

## 논리 연산자와 비트 연산자

### 논리 OR (`||`)

논리 OR는 전체 표현식이 참이 되기 위해 두 불리언 피연산자 중 하나 또는 둘 다 참이어야 함을 나타냅니다. 진리표로 표현하면:

| P | Q | P \|\| Q |
|---|---|--------|
| T | T | T      |
| T | F | T      |
| F | T | T      |
| F | F | F      |

이 연산자도 단락 평가(short-circuit) 연산자입니다. 예를 들어 `P || Q` 표현식에서 `P`가 `true`로 평가되면, `||`는 전체 표현식이 어쨌든 `true`로 평가되므로 표현식 `Q`를 평가하지 않습니다. Java는 `||` 표현식의 왼쪽에 있는 표현식 `P`가 참이면 전체 표현식이 반드시 참이라는 것을 알고 있기 때문입니다.

```java
boolean b1 = false, b2 = true;
boolean res = b2 || (b1 = true); // T || (평가되지 않음)
System.out.println(b1 + " " + b2 + " " + res); // false true true
```

위 코드에서 `b2`가 `true`이므로 표현식은 `T || (b1=true)`로 평가됩니다. 단락 평가가 발생하여 `(b1=true)` 하위 표현식이 실행되지 않습니다. 따라서 `b1`은 여전히 `false`입니다.

### 평가 순서 vs 우선 순위

이 주제는 종종 혼란을 야기하므로 코드 예제로 설명하겠습니다.

```java
int x = 2, y = 3, z = 4;
int res = x + y * z; // x + (y * z)
System.out.println(res); // 14
```

`*`는 `+`보다 우선 순위가 높기 때문에 공통 요소 `y`는 `x`가 아닌 `z`와 그룹화됩니다. 따라서 전체 표현식은 `x + (y * z) = 2 + 12 = 14`입니다.

중요한 점은 평가 순서가 왼쪽에서 오른쪽으로 진행되며, 평가 순서가 우선 순위보다 우선한다는 것입니다. 다음 예제를 살펴보겠습니다:

```java
boolean a = false, b = false, c = false;
// a || (b && c)
boolean bool = (a = true) || (b = true) && (c = true);
System.out.print(a + ", " + b + ", " + c); // true, false, false
```

`&&`는 `||`보다 우선 순위가 높으므로 표현식은 `(a = true) || ((b = true) && (c = true))`로 평가됩니다. 즉, 공통 하위 표현식 `(b = true)`는 `(a = true)`가 아닌 `(c = true)`와 그룹화됩니다. 

그러나 평가 순서가 우선 순위보다 우선하므로 `(a = true)`가 먼저 평가되어 `T || ((b = true) && (c = true))`가 됩니다. `||`는 단락 평가 연산자이므로 표현식의 나머지 부분(`||` 오른쪽)은 평가되지 않습니다. 이는 마지막 줄에서 `a`, `b`, `c`에 대해 각각 `true`, `false`, `false`가 출력되는 것으로 확인됩니다.

## 비트 연산자

비트 연산자는 논리 연산자와 유사하게 보이지만 완전히 다르게 작동합니다. 주요 차이점은 비트 연산자가 불리언과 정수형(byte, short, int, long, char) 피연산자 모두에 사용될 수 있다는 것입니다. 또한 비트 연산자는 단락 평가를 수행하지 않습니다.

### 비트 AND (`&`)

비트 AND(`&`)와 논리 AND(`&&`)를 비교하면, 차이점은 비트 AND가 단락 평가를 수행하지 않는다는 것입니다.

```java
boolean b1 = false, b2 = true;
boolean res = b1 & (b2 = false); // F & F
System.out.println(b1 + " " + b2 + " " + res); // false false false
```

이 경우 `&`가 단락 평가를 수행하지 않기 때문에 `(b2=false)` 하위 표현식이 실행됩니다. 따라서 `false & false`가 되어 `false`입니다. 모든 변수에 대해 `false`가 출력됩니다.

### 비트 OR (`|`)

비트 OR(`|`)와 논리 OR(`||`)를 비교하면, 차이점은 비트 OR가 단락 평가를 수행하지 않는다는 것입니다.

```java
boolean b1 = false, b2 = true;
boolean res = b2 | (b1 = true); // T | T
System.out.println(b1 + " " + b2 + " " + res); // true true true
```

이 경우 `|`가 단락 평가를 수행하지 않기 때문에 `(b1=true)` 하위 표현식이 실행됩니다. 따라서 `true | true`가 되어 `true`입니다. 모든 변수에 대해 `true`가 출력됩니다.

### 비트 XOR (`^`)

비트 XOR는 또 다른 단락 평가를 수행하지 않는 연산자입니다. 비트 XOR(`^`)는 피연산자 중 하나만 참이고 둘 다 참이 아닌 경우에만 `true`로 평가됩니다.

```java
boolean b1 = (5 > 1) ^ (10 < 20);   // T ^ T == F
boolean b2 = (5 > 10) ^ (10 < 20);  // F ^ T == T
boolean b3 = (5 > 1) ^ (10 < 2);    // T ^ F == T
boolean b4 = (5 > 10) ^ (10 < 2);   // F ^ F == F
System.out.println(b1 + " " + b2 + " " + b3 + " " + b4); // false true true false
```

- `b1`은 `false`입니다. 두 하위 표현식 `(5 > 1)`과 `(10 < 20)`이 모두 `true`이기 때문입니다.
- `b2`는 `true`입니다. `(5 > 10)`은 `false`지만 `(10 < 20)`은 `true`이고, `F ^ T`는 `true`입니다.
- `b3`은 `true`입니다. `(5 > 1)`은 `true`이고 `(10 < 2)`는 `false`이며, `T ^ F`는 `true`입니다.
- `b4`는 `false`입니다. `(5 > 10)`과 `(10 < 2)`가 모두 `false`이기 때문입니다.

> **참고**: 비트 연산자는 불리언 피연산자뿐만 아니라 정수형 피연산자에도 사용할 수 있으며, 각 비트에 대해 작업을 수행합니다. 이는 더 복잡한 비트 조작에 유용합니다.

## 비트 연산자(정수 피연산자)

비트 연산자는 일반적으로 자주 사용되지는 않지만, 정수형 피연산자에 대해 비트 단위로 연산을 수행할 수 있습니다:

```java
byte b1 = 6 & 8;       // 두 비트 모두 1이어야 함
byte b2 = 7 | 9;       // 하나 또는 둘 다 1이면 됨
byte b3 = 5 ^ 4;       // 하나만 1이어야 함(둘 다 아님)
System.out.println(b1 + ", " + b2 + ", " + b3); // 0, 15, 1
```

### 정수형 피연산자에서 각 비트 연산자의 작동 방식:
- 비트 AND(&): 두 비트가 모두 1이어야 결과 비트가 1이 됩니다.
```
  6 & 8 (이진수) = 0110 & 1000 = 0000 = 0
```

- 비트 OR(|): 두 비트 중 하나 또는 둘 다 1이면 결과 비트가 1이 됩니다.
```
  7 | 9 (이진수) = 0111 | 1001 = 1111 = 15
```

- 비트 XOR(^): 두 비트 중 하나만 1이고 둘 다 1이 아닐 때 결과 비트가 1이 됩니다.
```
  5 ^ 4 (이진수) = 0101 ^ 0100 = 0001 = 1
```

## 삼항 연산자

삼항 연산자는 세 개의 피연산자를 가지는 연산자로, 불리언 표현식을 평가하고 그 결과에 따라 값을 선택하는 데 사용됩니다.


구문:
```
변수 = 불리언_표현식 ? 참일_때_값 : 거짓일_때_값
```

거짓일_때_값


예제:

```java
int x = 4;
String s = x % 2 == 0 ? " is an even number" : " is an odd number";
System.out.println(x + s); // 4 is an even number
```



위 코드에서 불리언 표현식 x % 2 == 0이 true로 평가되므로(x가 4이기 때문에), 문자열 s에 " is an even number"가 할당됩니다. 만약 x가 5였다면 표현식은 false로 평가되어 " is an odd number"가 할당되었을 것입니다.


## 복합 할당 연산자
복합 할당 연산자는 더 길고 자세한 표현식을 간결하게 작성할 수 있게 해줍니다:
- += 예: x += y는 x = x + y와 같음
- -= 예: x -= y는 x = x - y와 같음
- *= 예: x *= y는 x = x * y와 같음
- /= 예: x /= y는 x = x / y와 같음
- %= 예: x %= y는 x = x % y와 같음


비트 연산자에 대한 복합 할당 연산자도 있습니다(예: x &= 3은 x = x & 3과 같음).

### 복합 할당 연산자의 특징


1. 내장된 캐스팅:

```java
   byte b1 = 3, b2 = 4;
   //  b1 = b1 + b2;         // 컴파일러 오류
   b1 = (byte)(b1 + b2);     // 정상, 명시적 캐스트 필요
   b1 += b2;                 // 정상, 캐스트 필요 없음
```

b1 + b2는 int 타입을 결과로 내어 byte 변수에 직접 할당할 수 없습니다. 명시적 캐스트 (byte)를 사용하거나, 복합 할당 연산자 +=를 사용하면 컴파일러가 내부적으로 캐스팅을 수행합니다. 즉, b1 += b2는 내부적으로 b1 = (byte)(b1 + b2)로 변환됩니다.


2. 오른쪽 피연산자의 그룹화:
```java
   int x = 2;
   x *= 2 + 5;                   // x = x * (2 + 5) = 2 * 7 = 14
   System.out.println(x); // 14
```

복합 할당 연산자의 오른쪽에 있는 표현식은 우선 순위에 관계없이 그룹화됩니다. 일반적으로 *가 +보다 우선 순위가 높지만, 여기서는 2 + 5가 괄호로 묶여 2 * (2 + 5) = 14로 평가됩니다. 만약 그렇지 않았다면 (2 * 2) + 5 = 9가 되었을 것입니다.


3. 복잡한 표현식의 평가:
```java
   int k = 1;
   k += (k = 4) * (k + 2); // k = k + ((k = 4) * (k + 2))
   System.out.println(k); // 25
```

평가 순서는 왼쪽에서 오른쪽으로 진행됩니다:


- k += (k = 4) * (k + 2)는 k = k + ((k = 4) * (k + 2))로 변환됩니다.
- 현재 k의 값 1을 대입하면: k = 1 + ((k = 4) * (k + 2))
- (k = 4)가 먼저 평가되면 k는 4가 됩니다.
- 그 다음 (k + 2)는 (4 + 2) = 6이 됩니다.
- 따라서: k = 1 + (4 * 6) = 1 + 24 = 25


이로써 Java 연산자에 대한 설명을 마치고, 다음으로 이미 이 장에서 간략히 다루었던 Java 캐스팅에 대해 살펴볼 것입니다.

##Java 캐스팅 이해하기

Java 캐스팅을 제대로 이해하려면 Java의 기본 데이터 타입의 확장(widening)과 축소(narrowing)에 대해 알아야 합니다. 먼저 기본 데이터 타입의 바이트 크기를 기억하는 것이 도움이 됩니다.

기본 데이터 타입의 크기
| 데이터 타입 | 크기(바이트) |
|------------|-------------|
| boolean | 1 |
| byte | 1 |
| char | 2 |
| short | 2 |
| int | 4 |
| float | 4 |
| long | 8 |
| double | 8 |

## 확장(Widening)

확장은 자동으로 수행됩니다. 즉, 캐스트가 필요하지 않습니다. 이러한 자동 변환을 묵시적 타입 변환(implicit promotion)이라고도 합니다. 확장 규칙은 다음과 같습니다:
```
byte → short/char → int → long → float → double
```

위 표의 크기를 고려하면 대부분의 규칙은 이해하기 쉽습니다. 예를 들어, byte는 1바이트이고 short는 2바이트이므로 byte가 자동으로 short에 들어갈 수 있습니다.


흥미로운 점은 long → float입니다. 이는 8바이트에서 4바이트로의 확장인데, long이 8바이트를 필요로 하고 float은 4바이트만 필요하지만 범위가 다르기 때문에 가능합니다. float 타입은 어떤 long 값도 수용할 수 있지만 그 반대는 불가능합니다.

```java
System.out.println("Float: " + Float.MAX_VALUE);  // Float: 3.4028235E38
System.out.println("Float: " + Float.MIN_VALUE);  // Float: 1.4E-45
System.out.println(Long.MAX_VALUE);               // 9223372036854775807
System.out.println(Long.MIN_VALUE);               // -9223372036854775808
```


부동 소수점에 사용되는 과학적 표기법 E에 주목하세요. float는 더 적은 공간을 차지하지만, 표현 방식 덕분에 long보다 더 크고 작은 숫자를 담을 수 있습니다.


### 과학적 표기법


과학적 표기법은 십진수를 간단하게 표현하는 방법으로, 매우 크거나 매우 작은 숫자를 표현할 때 유용합니다.

```java
double d1 = .00000000123;
double d2 = 1.23e-9;
System.out.println(d1==d2); // true

double d3 = 120_000_000;
double d4 = 1.2e+8;
System.out.println(d3==d4); // true
```


두 비교 모두 true를 반환하므로, d1은 d2의 내부 표현과 동일하고, d3와 d4도 동등합니다.


### 확장 예제
```java
char c = 'a';
int i = c;
float f = i;
double d = f;
float g = 9223372036854775807L;
```


첫 번째 줄은 일반적인 char 할당으로, 확장이 관여하지 않습니다. 문자(char)는 단순히 작은 숫자(0..65,535)라는 점에 유의하세요. 문자를 표현하기 위해 작은따옴표로 감싸고, 문자열(String)은 큰따옴표로 감쌉니다. 따라서 "a"는 문자열이고, 'a'는 문자입니다.


두 번째 줄은 char(2바이트)에서 int(4바이트)로의 확장입니다. 세 번째 줄은 int에서 float로의 확장입니다. int와 float 모두 4바이트가 필요하지만, 앞서 long과 논의했듯이 float이 더 넓은 범위를 가지므로 문제가 없습니다. 네 번째 줄은 float에서 double로의 확장입니다. 마지막으로, 다섯 번째 줄은 long에서 float로의 확장입니다.


모든 할당에서 컴파일러 오류가 없으며, 캐스트 연산자가 필요하지 않다는 점에 주목하세요.


## 축소(Narrowing)


축소는 명시적 캐스팅이 필요한 형변환입니다. 축소를 사용할 때에는 항상 데이터 손실 가능성을 고려해야 합니다.


### byte 오버플로

byte의 범위는 -128(10000000)에서 +127(01111111)임을 기억하세요. 가장 왼쪽 비트는 부호 비트로, 1은 음수를, 0은 양수를 나타냅니다.

앞의 예시에서 우리는 다음과 같이 했습니다:
```java
byte b = (byte) 233;
```

233(정수)은 byte에 비해 너무 크지만 b가 어떻게 -23 값을 가지게 되었을까요? int 타입으로 233을 표현하면 다음과 같은 비트 패턴이 됩니다:

11101001 = 1 + 8 + 32 + 64 + 128 = 233 (int)

int는 4바이트이므로 233은 실제로 00000000000000000000000011101001입니다. 이 비트 패턴을 byte로 변환하면(상위 3바이트는 잘림) 다음과 같은 출력이 나옵니다:

11101001 = 1 + 8 + 32 + 64 + (-128) = -23 (byte)

가장 왼쪽 비트가 부호 비트라는 점을 기억하세요. 그래서 계산에 -128이 포함됩니다. 이는 -(2^7) = -128입니다.

## 캐스팅을 해야 할지 말아야 할지, 그것이 문제로다

컴파일러가 백그라운드에서 규칙을 적용하기 때문에 캐스트가 필요하지 않은 특정 상황들이 있습니다. 코드 예제를 통해 이러한 상황들을 살펴보겠습니다. 그림 3.8은 코드를 보여줍니다:

32번 라인은 char 변수 c를 선언하고 int 값 12로 초기화합니다. char 변수는 본질적으로 작은 양수입니다. int 값(4바이트)을 char 변수(2바이트)에 할당하고 있지만, 리터럴 값이 char 범위(0에서 65,535) 내에 있기 때문에 컴파일러는 이를 허용합니다. 리터럴 값이 char 범위를 벗어났다면 컴파일러는 오류를 생성했을 것입니다 - 이는 33번 라인에서 발생하는 상황입니다.

34번 라인은 short 변수 s를 선언하고 int 값 12로 초기화합니다. 마찬가지로, short는 2바이트만 저장할 수 있지만, 컴파일러는 리터럴 값 12를 저장할 수 있다는 것을 인식하고 이를 허용합니다.

컴파일러 관점에서 리터럴 값을 변수에 할당하는 것은 변수를 변수에 할당하는 것과는 다릅니다. 예를 들어, 32번 라인과 37번 라인은 매우 다릅니다. 이는 다음 몇 줄을 논의하면서 더 명확해질 것입니다.

35번부터 38번 라인은 char와 short가 모두 2바이트를 필요로 하지만, 각각 다른 범위를 가진다는 것을 보여줍니다: char(0에서 65,535)와 short(-32,768에서 +32,767). 이는 short 변수가 -15와 같은 음수 값을 가질 수 있는 반면, char 변수는 그럴 수 없다는 것을 의미합니다. 반대로, char 변수는 65,000과 같은 값을 가질 수 있지만 short 변수는 그럴 수 없습니다. 따라서 35번과 37번 라인이 보여주는 것처럼, char 변수를 short 변수에 직접 할당하거나 그 반대로 할 수 없습니다. 두 시나리오 모두 캐스트가 필요합니다. 36번과 38번 라인이 이를 보여줍니다.

### 컴파일 타임 상수

하지만 40~42번 라인은 방금 설명한 캐스트 요구 사항을 우회하는 방법을 보여줍니다. 변수를 컴파일 타임 상수로 선언하면(그리고 값이 범위 내에 있다고 가정하면), 컴파일러는 변수 간 할당을 허용합니다. 40번 라인은 final 키워드를 사용하여 컴파일 타임 상수를 선언합니다. final에 대해서는 9장에서 자세히 논의할 것이지만, 이 맥락에서는 c1이 항상 12의 값을 가진다는 것을 의미합니다. 값은 c1에 대해 고정(또는 상수)되며 이는 컴파일 타임에 이루어집니다. c1의 값을 변경하려고 하면 컴파일러 오류가 발생합니다. 이제 컴파일러는 c1이 항상 12의 값을 가진다는 것을 알기 때문에, 리터럴 값에 적용하는 동일한 규칙을 적용할 수 있습니다. 다시 말해, 값이 범위 내에 있는지를 확인합니다. 이것이 42번 라인이 컴파일러 오류를 생성하지 않는 이유입니다.

이로써 연산자에 대한 논의를 마칩니다. 이제 이를 적용해 봅시다!

## 연습 문제

메소조익 에덴은 잘 운영되고 있습니다. 공룡들은 건강하고 방문객들은 행복합니다. 이제 새로운 기술을 배웠으니, 조금 더 복잡한 작업을 수행해 봅시다!

1. 관리인들은 공룡의 체중을 추적할 수 있기를 원합니다. 두 공룡의 평균 체중을 계산하는 프로그램을 작성하는 것이 당신의 임무입니다. 이는 영양사 팀이 올바른 음식 양을 계획하는 데 도움이 될 것입니다.

2. 적절한 영양은 공룡의 건강에 필수적입니다. 관리인들은 공룡을 얼마나 먹여야 하는지에 대한 대략적인 지침을 갖고 싶어합니다. 공룡의 체중에 기반하여 필요한 음식의 양을 결정하는 프로그램을 작성하세요. 공룡의 체중 단위당 필요한 음식의 양을 직접 생각해낼 수 있습니다.

3. 우리 공원에는 윤년 확인기가 필요합니다. 과학적 정확성에 대한 우리의 헌신으로, 모듈러스 연산자를 사용하여 현재 연도가 윤년인지 결정하세요. 우리는 달력 테마 전시가 항상 최신 상태인지 확인하고 싶습니다.

4. 공원의 최대 수용 인원에 도달했는지 확인하는 프로그램을 만드세요. 프로그램은 "최대 수용 인원 도달:" 다음에 true 또는 false만 출력하면 됩니다. 이는 안전 기준을 유지하고 방문객 경험을 긍정적으로 보장하는 데 중요합니다.

5. 때로는 방문객들이 공룡의 나이를 비교하고 싶어합니다. 그리고 우리는 이해합니다 - 이는 교육적 목적으로 흥미로울 수 있습니다. 두 공룡 사이의 나이 차이를 계산하는 프로그램을 작성하세요.

6. 메소조익 에덴에서 우리는 매우 강한 안전 우선 정책을 가지고 있습니다. 공원의 안전 등급이 특정 임계값 이상인지 확인하는 프로그램을 작성하세요. 좋은 안전 등급을 유지하는 것이 우리의 최우선 과제입니다.

## 프로젝트 - 공룡 식사 계획기

메소조익 에덴의 사육사로서, 중요한 임무 중 하나는 우리의 사랑스러운 공룡들을 위한 식사 계획을 세우는 것입니다. 아직 조건문과 루프를 배우지 않았지만, 여전히 기본적인 요구 사항을 계산할 수 있습니다!

사육사들이 다양한 공룡을 위한 식사 양을 계획하는 데 도움이 되는 간단한 프로그램을 개발하세요. 프로그램은 공룡의 체중을 사용하여 식사당 필요한 음식의 양을 계산해야 합니다.

더 많은 지침이 필요하다면, 다음과 같이 할 수 있습니다:

- 공룡의 체중과 하루에 필요한 체중 비율에 대한 변수를 선언하세요. 예를 들어, 공룡이 하루에 체중의 5%를 먹어야 하고, 체중이 2,000 kg이라면, 하루에 100 kg의 음식이 필요합니다.

- 이제, 공룡을 하루에 두 번 먹인다고 가정해 보세요. 먹이는 횟수에 대한 변수를 선언하고 먹이를 줄 때마다 얼마나 많은 음식이 필요한지 계산하세요. 이 예시에서는 먹이를 줄 때마다 50 kg이 필요합니다.

- 결과를 의미 있는 방식으로 출력하세요. 예를 들어, "우리의 2,000 kg 공룡은 하루에 100 kg의 음식이 필요하며, 이는 먹이를 줄 때마다 50 kg을 제공해야 한다는 것을 의미합니다."

## 요약

이 장에서 우리는 Java의 연산자가 어떻게 작동하고 협력하는지, 그리고 Java에서 어떻게 캐스팅하는지 배웠습니다.

처음에는 연산자와 관련된 두 가지 중요한 속성인 우선 순위와 결합성에 대해 논의했습니다. 우선 순위는 공통 항이 어떻게 그룹화되는지를 지시하는 것을 보았습니다. 결합성은 연산자가 동일한 우선 순위를 가질 때 적용됩니다.

그런 다음 연산자 자체를 검토했습니다. 우리는 전위/후위 증가/감소 연산자인 ++와 -- 같이 피연산자가 하나인 단항 연산자부터 시작했습니다.

그 다음에는 산술 연산자인 +, -, *, /, %를 살펴보았습니다. 정수 나눗셈이 소수점을 버린다는 점에 주목했습니다. 또한, int 타입 또는 그보다 작은 타입을 포함하는 모든 수학 연산의 결과는 int라는 것을 논의했습니다. 마지막으로, 하나 또는 두 피연산자가 문자열일 때 + 연산자가 어떻게 작동하는지 자세히 논의했습니다. 이 경우에는 문자열 추가가 수행됩니다.

다음으로, 관계 연산자에 대해 논의했습니다. 이 연산자들의 결과는 항상 불리언 값이며, 이는 4장에서 조건문을 구성할 때 사용될 것입니다.

Java는 타입이 다른 연산을 수행할 수 없기 때문에, 가능한 경우 묵시적 타입 변환을 수행합니다. 이는 Java가 메모리 어딘가에서 더 작은 타입을 더 큰 타입으로 자동 변환하는 것입니다. 이는 Java가 보이지 않게 연산을 계속하는 방법입니다.

그런 다음 논리 연산자인 &&, ||, &, |, ^에 대해 논의했습니다. 이해를 돕기 위해 진리표를 제시했습니다. 논리 &&와 논리 || 연산자는 모두 단락 평가 연산자입니다. 이를 이해하는 것은 평가 순서가 우선 순위보다 우선한다는 점에서 중요합니다.

비트 연산자인 비트 AND(&)와 비트 OR(|)는 유사하지만, &&와 ||와 달리 &와 |는 절대 단락 평가를 수행하지 않으며 정수 피연산자와도 작동할 수 있다는 차이점이 있습니다.

삼항 연산자는 세 개의 피연산자를 취합니다. 이는 불리언 표현식을 평가하고, 불리언 표현식이 참인지 거짓인지에 따라 변수에 두 값 중 하나를 할당합니다.

연산자와 관련하여, 마지막으로 다룬 그룹은 복합 할당 연산자로, 각 수학 연산자에 대해 하나씩 있습니다.

캐스팅에 대한 논의에서는 확장과 축소를 모두 다루었습니다. 확장은 백그라운드에서 수행되며 종종 묵시적 타입 변환이라고 불립니다. 여기서는 승격되는 타입이 대상 타입에 쉽게 맞기 때문에 위험이 없습니다.

축소는 캐스트가 필요한 경우입니다. 이는 더 많은 저장 공간을 필요로 하는 타입에서 더 적은 저장 공간을 필요로 하는 타입으로 가는 것이기 때문에, 데이터 손실 가능성이 있기 때문입니다.

이제 연산자 사용 방법을 알았으니, 다음 장에서는 연산자가 일반적으로 사용되는 조건문으로 넘어가겠습니다.
